/*
 * Harbor API
 * These APIs provide services for manipulating Harbor project.
 *
 * OpenAPI spec version: 1.7.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package com.imwyh.harbor.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.swagger.v3.oas.annotations.media.Schema;
import java.io.IOException;

/**
 * RepFilter
 */

@javax.annotation.Generated(value = "io.swagger.codegen.v3.generators.java.JavaClientCodegen", date = "2019-05-14T14:29:11.153+08:00[Asia/Shanghai]")public class RepFilter {

  @SerializedName("kind")
  private String kind = null;

  @SerializedName("value")
  private String value = null;

  @SerializedName("pattern")
  private String pattern = null;

  @SerializedName("metadata")
  private Object metadata = null;
  public RepFilter kind(String kind) {
    this.kind = kind;
    return this;
  }

  

  /**
  * The replication policy filter kind. The valid values are project, repository and tag.
  * @return kind
  **/
  @Schema(description = "The replication policy filter kind. The valid values are project, repository and tag.")
  public String getKind() {
    return kind;
  }
  public void setKind(String kind) {
    this.kind = kind;
  }
  public RepFilter value(String value) {
    this.value = value;
    return this;
  }

  

  /**
  * The value of replication policy filter. When creating repository and tag filter, filling it with the pattern as string. When creating label filter, filling it with label ID as integer.
  * @return value
  **/
  @Schema(description = "The value of replication policy filter. When creating repository and tag filter, filling it with the pattern as string. When creating label filter, filling it with label ID as integer.")
  public String getValue() {
    return value;
  }
  public void setValue(String value) {
    this.value = value;
  }
  public RepFilter pattern(String pattern) {
    this.pattern = pattern;
    return this;
  }

  

  /**
  * Depraceted, use value instead. The replication policy filter pattern.
  * @return pattern
  **/
  @Schema(description = "Depraceted, use value instead. The replication policy filter pattern.")
  public String getPattern() {
    return pattern;
  }
  public void setPattern(String pattern) {
    this.pattern = pattern;
  }
  public RepFilter metadata(Object metadata) {
    this.metadata = metadata;
    return this;
  }

  

  /**
  * This map object is the replication policy filter metadata.
  * @return metadata
  **/
  @Schema(description = "This map object is the replication policy filter metadata.")
  public Object getMetadata() {
    return metadata;
  }
  public void setMetadata(Object metadata) {
    this.metadata = metadata;
  }
  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    RepFilter repFilter = (RepFilter) o;
    return Objects.equals(this.kind, repFilter.kind) &&
        Objects.equals(this.value, repFilter.value) &&
        Objects.equals(this.pattern, repFilter.pattern) &&
        Objects.equals(this.metadata, repFilter.metadata);
  }

  @Override
  public int hashCode() {
    return java.util.Objects.hash(kind, value, pattern, metadata);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class RepFilter {\n");
    
    sb.append("    kind: ").append(toIndentedString(kind)).append("\n");
    sb.append("    value: ").append(toIndentedString(value)).append("\n");
    sb.append("    pattern: ").append(toIndentedString(pattern)).append("\n");
    sb.append("    metadata: ").append(toIndentedString(metadata)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}
